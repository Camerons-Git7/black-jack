<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üí£ Word Bomb üí£</title>
    <link rel="icon" type="image/x-icon" href="https://math.hws.edu/favicon.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; overflow: hidden; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .game-font { font-family: 'Fredoka One', cursive; }
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .pulse-red { animation: pulseRed 1s infinite; }
        @keyframes pulseRed {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(239, 68, 68, 0); }
        }
        .float { animation: float 3s ease-in-out infinite; }
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        .bomb-container { position: relative; width: 160px; height: 160px; margin: 0 auto; }
        .fuse {
            position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
            width: 4px; height: 30px; background: #ff6b6b; border-radius: 2px; transition: height 0.1s linear;
        }
        .spark {
            position: absolute; top: -25px; left: 50%; transform: translateX(-50%);
            width: 8px; height: 8px; background: radial-gradient(circle, #ffd93d 0%, #ff6b6b 100%);
            border-radius: 50%; box-shadow: 0 0 10px #ffd93d, 0 0 20px #ff6b6b; animation: sparkle 0.5s infinite alternate;
        }
        @keyframes sparkle {
            from { transform: translateX(-50%) scale(1); opacity: 1; }
            to { transform: translateX(-50%) scale(1.5); opacity: 0.8; }
        }
        .explosion {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 0; height: 0; border-radius: 50%; background: radial-gradient(circle, #ff6b6b 0%, #ffd93d 50%, transparent 70%);
            opacity: 0; pointer-events: none;
        }
        .explode-animation { animation: explode 0.6s ease-out forwards; }
        @keyframes explode {
            0% { width: 0; height: 0; opacity: 1; }
            50% { width: 400px; height: 400px; opacity: 0.8; }
            100% { width: 600px; height: 600px; opacity: 0; }
        }
        .letter-card { transition: all 0.3s ease; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .letter-card:hover { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
        .player-avatar {
            width: 50px; height: 50px; border-radius: 50%; display: flex;
            align-items: center; justify-content: center; font-size: 20px; font-weight: bold; transition: all 0.3s ease;
        }
        .player-active { box-shadow: 0 0 0 4px #fbbf24, 0 0 20px rgba(251, 191, 36, 0.5); transform: scale(1.1); }
        .player-dead { opacity: 0.4; filter: grayscale(100%); }
        .word-history-item { animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
        .difficulty-easy { color: #10b981; }
        .difficulty-medium { color: #f59e0b; }
        .difficulty-hard { color: #ef4444; }
        .loading-spinner {
            border: 3px solid #f3f3f3; border-top: 3px solid #6366f1; border-radius: 50%;
            width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .validation-status { position: absolute; right: 4rem; top: 50%; transform: translateY(-50%); }
        .game-container { height: 100vh; max-height: 100vh; display: flex; flex-direction: column; }
        .main-content { flex: 1; overflow: hidden; display: flex; }
        .center-panel { display: flex; flex-direction: column; justify-content: center; }
        .scroll-section { max-height: 100%; overflow-y: auto; }
        #wordHistory { max-width: 100%; }
        .room-code-input { letter-spacing: 0.5em; text-align: center; font-family: monospace; font-size: 2rem; }
        .mode-btn { transition: all 0.3s ease; }
        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; transform: scale(1.05);
        }
        .lobby-panel { display: none; }
        .lobby-panel.active { display: block; }
        .game-panel { display: none; height: 100%; }
        .game-panel.active { display: flex; }
        .home { display: none; height: 100%; align-items: center; justify-content: center; overflow-y: auto; }
        .home-panel { display: none; height: 100%; align-items: center; justify-content: center; overflow-y: auto; }
        .home-panel.active { display: flex; }
        .bottom-bar { min-height: 60px; }
        .home-content { width: 100%; max-width: 500px; padding: 1rem; }
        .connection-status {
            position: fixed; top: 20px; right: 20px; padding: 8px 16px; border-radius: 20px;
            font-size: 12px; font-weight: bold; z-index: 100; transition: all 0.3s;
        }
        .status-connecting { background: #fbbf24; color: #92400e; }
        .status-connected { background: #10b981; color: white; }
        .status-error { background: #ef4444; color: white; }
        .status-disconnected { background: #6b7280; color: white; }
        
        @media (max-height: 700px) {
            .bomb-container { width: 120px; height: 120px; }
            .home-content { padding: 0.5rem; }
            .mode-btn { padding: 1rem; }
            .mode-btn .text-4xl { font-size: 2rem; }
        }
        @media (max-height: 600px) {
            .home-panel { align-items: flex-start; padding-top: 1rem; }
        }
    </style>
</head>
<body class="flex items-center justify-center">
    <!-- Connection Status -->
    <div id="connectionStatus" class="connection-status status-disconnected hidden">Disconnected</div>

    <!-- Audio Context Starter -->
    <div id="audioStarter" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-2xl p-6 max-w-sm mx-4 text-center shadow-2xl">
            <div class="text-5xl mb-3">üéµ</div>
            <h2 class="text-2xl font-bold mb-3 game-font text-gray-800">Ready to Play?</h2>
            <p class="text-gray-600 mb-4 text-sm">Click below to start with audio enabled!</p>
            <button onclick="startAudio()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-full transition-all transform hover:scale-110 shadow-lg">
                Start Game ‚ñ∂Ô∏è
            </button>
        </div>
    </div>

    <!-- Main Game Container -->
    <div id="gameContainer" class="w-full max-w-6xl h-screen bg-white rounded-none lg:rounded-3xl shadow-2xl overflow-hidden opacity-0 transition-opacity duration-500 game-container">
        
        <!-- Header -->
        <div class="bg-gradient-to-r from-indigo-600 to-purple-600 p-3 text-white shrink-0">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-2xl game-font tracking-wide">üí£ WORD BOMB</h1>
                    <p class="text-indigo-200 text-xs mt-0" id="modeIndicator">Select a mode</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="toggleMute()" id="muteBtn" class="p-2 bg-white bg-opacity-20 rounded-lg hover:bg-opacity-30 transition">üîä</button>
                    <button onclick="showRules()" class="p-2 bg-white bg-opacity-20 rounded-lg hover:bg-opacity-30 transition">‚ÑπÔ∏è</button>
                    <button onclick="returnToHome()" id="homeBtn" class="p-2 bg-white bg-opacity-20 rounded-lg hover:bg-opacity-30 transition hidden">üè†</button>
                </div>
            </div>
        </div>

        <!-- HOME PANEL -->
        <div id="homePanel" class="home-panel active flex-1">
            <div class="home-content">
                <div class="text-center mb-6">
                    <div class="text-5xl mb-3">üí£</div>
                    <h2 class="text-3xl font-bold game-font text-gray-800">Word Bomb</h2>
                    <p class="text-gray-600 mt-2 text-sm">Choose your game mode</p>
                </div>

                <div class="space-y-3 mb-4">
                    <button onclick="startSinglePlayer()" class="w-full mode-btn p-5 rounded-xl border-2 border-indigo-200 hover:border-indigo-500 bg-indigo-50 hover:bg-indigo-100 transition-all text-left flex items-center gap-4">
                        <div class="text-4xl">üéÆ</div>
                        <div>
                            <div class="font-bold text-lg text-gray-800">Single Player</div>
                            <div class="text-sm text-gray-600">Play against 3 bots</div>
                        </div>
                    </button>

                    <button onclick="showMultiplayerOptions()" class="w-full mode-btn p-5 rounded-xl border-2 border-purple-200 hover:border-purple-500 bg-purple-50 hover:bg-purple-100 transition-all text-left flex items-center gap-4">
                        <div class="text-4xl">üåê</div>
                        <div>
                            <div class="font-bold text-lg text-gray-800">Multiplayer</div>
                            <div class="text-sm text-gray-600">Play with friends using peer-to-peer connection</div>
                        </div>
                    </button>
                </div>

                <div id="multiplayerOptions" class="space-y-3 hidden">
                    <div class="border-t pt-3">
                        <div class="flex gap-2 mb-3">
                            <button onclick="showCreateRoom()" class="flex-1 py-2.5 bg-green-500 hover:bg-green-600 text-white rounded-lg font-bold transition text-sm">Create Room</button>
                            <button onclick="showJoinRoom()" class="flex-1 py-2.5 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-bold transition text-sm">Join Room</button>
                        </div>

                        <!-- Create Room Section -->
                        <div id="createRoomSection" class="hidden">
                            <div class="bg-green-50 p-4 rounded-xl text-center">
                                <div class="text-sm text-green-700 mb-2 font-semibold">Your Room Code:</div>
                                <div id="generatedRoomCode" class="text-4xl font-mono font-bold text-green-800 mb-3 tracking-widest bg-white py-2 rounded-lg shadow-inner">------</div>
                                <div class="flex gap-2 justify-center mb-3">
                                    <button onclick="copyRoomCode(event)" class="bg-gray-600 text-white px-3 py-1.5 rounded-lg text-sm hover:bg-gray-700 transition">Copy Code</button>
                                </div>
                                <div class="text-xs text-green-600 mb-2">Waiting for players to join...</div>
                                <div id="playersInRoom" class="text-sm font-semibold text-green-700 bg-white inline-block px-3 py-1 rounded-full">Players: 1/4</div>
                                <div id="peerIdDisplay" class="text-xs text-gray-500 mt-2 break-all"></div>
                                <button onclick="startMultiplayerGame()" id="startMultiBtn" class="mt-3 w-full py-2.5 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>Start Game</button>
                                <div class="text-xs text-gray-500 mt-1">Need 2-4 players to start</div>
                                <button onclick="closeRoom()" class="mt-2 w-full py-2 bg-red-500 text-white rounded-lg font-bold hover:bg-red-600 transition text-sm">Close Room</button>
                            </div>
                        </div>

                        <!-- Join Room Section -->
                        <div id="joinRoomSection" class="hidden">
                            <div class="bg-blue-50 p-4 rounded-xl">
                                <div class="text-sm text-blue-700 mb-2 font-semibold text-center">Enter Room Code to Join:</div>
                                <input 
                                    type="text" 
                                    id="roomCodeInput" 
                                    class="w-full px-4 py-3 text-lg border-2 border-blue-300 rounded-xl focus:outline-none focus:border-blue-500 bg-white shadow-inner text-center font-mono"
                                    placeholder="Enter Room Code..."
                                    maxlength="6"
                                >
                                <button onclick="joinRoom()" class="mt-3 w-full py-2.5 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700 transition">Connect to Host</button>
                                <button onclick="cancelJoin()" class="mt-2 w-full py-2 bg-gray-500 text-white rounded-lg font-bold hover:bg-gray-600 transition text-sm">Cancel</button>
                                <div id="joinStatus" class="mt-2 text-sm text-center min-h-[20px]"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- GAME PANEL -->
        <div id="gamePanel" class="game-panel flex-col lg:flex-row flex-1 overflow-hidden">
            <!-- Left Panel: Players -->
            <div class="lg:w-1/4 bg-gray-50 p-3 border-b lg:border-b-0 lg:border-r border-gray-200 shrink-0 overflow-y-auto">
                <h3 class="text-base font-bold text-gray-700 mb-2 flex items-center gap-2">
                    <span>üë•</span> Players
                </h3>
                <div id="playersList" class="space-y-2"></div>
                
                <div class="mt-3 p-3 bg-indigo-50 rounded-xl">
                    <h4 class="text-indigo-900 mb-1 text-sm font-bold">üéØ Challenge</h4>
                    <div id="challengeDisplay" class="text-indigo-700 font-semibold text-xs">
                        Type words containing the letters shown!
                    </div>
                    <div class="mt-1 text-xs text-indigo-600">
                        Time decreases by 0.5s per word!
                    </div>
                </div>
                
                <div id="networkInfo" class="mt-3 p-2 bg-gray-100 rounded-lg text-xs text-gray-600 hidden">
                    <div class="font-bold mb-1">Network Info:</div>
                    <div id="networkStatus">Not connected</div>
                </div>
            </div>

            <!-- Center Panel: Game Action -->
            <div class="lg:w-3/4 p-4 flex flex-col items-center justify-center center-panel overflow-y-auto">
                
                <!-- Bomb Section -->
                <div class="bomb-container mb-4 float">
                    <div class="fuse" id="fuse"></div>
                    <div class="spark" id="spark"></div>
                    <svg viewBox="0 0 200 200" class="w-full h-full drop-shadow-2xl">
                        <circle cx="100" cy="110" r="70" fill="#2d3748" stroke="#1a202c" stroke-width="3"/>
                        <circle cx="100" cy="110" r="65" fill="url(#bombGradient)"/>
                        <ellipse cx="75" cy="85" rx="20" ry="15" fill="rgba(255,255,255,0.3)" transform="rotate(-45 75 85)"/>
                        <rect x="95" y="25" width="10" height="20" fill="#4a5568"/>
                        <defs>
                            <radialGradient id="bombGradient" cx="30%" cy="30%">
                                <stop offset="0%" style="stop-color:#4a5568;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#1a202c;stop-opacity:1" />
                            </radialGradient>
                        </defs>
                    </svg>
                    <div class="explosion" id="explosion"></div>
                </div>

                <!-- Timer Display -->
                <div class="text-center mb-4">
                    <div class="text-5xl font-bold game-font bomb-text text-gray-800" id="timerDisplay">10.00</div>
                    <div class="text-gray-500 text-xs mt-1">seconds remaining</div>
                    <div id="baseTimeDisplay" class="text-xs text-gray-400 mt-1">Base time: 10.0s</div>
                </div>

                <!-- Required Letters Display -->
                <div class="mb-4 w-full max-w-md">
                    <div class="text-center mb-2 text-gray-600 font-semibold text-sm">Required Letters:</div>
                    <div id="lettersContainer" class="flex justify-center gap-2 flex-wrap"></div>
                    <div id="difficultyIndicator" class="text-center mt-2 text-xs font-bold difficulty-medium">
                        Medium Difficulty
                    </div>
                </div>

                <!-- Input Section -->
                <div class="w-full max-w-md relative">
                    <input 
                        type="text" 
                        id="wordInput" 
                        class="w-full px-4 py-3 text-lg border-4 border-indigo-300 rounded-xl focus:outline-none focus:border-indigo-500 game-font text-center uppercase tracking-wider transition-all shadow-lg"
                        placeholder="TYPE WORD HERE..."
                        autocomplete="off"
                        disabled
                    >
                    <div class="validation-status" id="validationStatus"></div>
                    <div class="absolute right-4 top-1/2 transform -translate-y-1/2">
                        <span id="inputStatus" class="text-2xl"></span>
                    </div>
                </div>

                <!-- Controls -->
                <div class="flex gap-2 mt-4">
                    <button onclick="submitWord()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-lg transform hover:scale-105 transition-all disabled:opacity-50 disabled:cursor-not-allowed text-sm" id="submitBtn" disabled>
                        SUBMIT ‚úì
                    </button>
                </div>

                <!-- Message Display -->
                <div id="messageDisplay" class="mt-3 h-6 text-center font-bold text-base transition-all"></div>
                
                <!-- API Status -->
                <div id="apiStatus" class="mt-1 text-xs text-gray-400"></div>
            </div>
        </div>

        <!-- Bottom Panel: Word History & Stats -->
        <div class="bg-gray-100 p-3 border-t border-gray-200 shrink-0 bottom-bar">
            <div class="flex flex-col md:flex-row justify-between items-center gap-2 h-full">
                <div class="flex items-center gap-2">
                    <div class="bg-white px-3 py-1 rounded-lg shadow">
                        <span class="text-gray-500 text-xs">Round</span>
                        <span id="roundDisplay" class="font-bold text-lg ml-1 text-indigo-600">1</span>
                    </div>
                    <div class="bg-white px-3 py-1 rounded-lg shadow">
                        <span class="text-gray-500 text-xs">Words</span>
                        <span id="wordsUsedDisplay" class="font-bold text-lg ml-1 text-purple-600">0</span>
                    </div>
                </div>
                
                <div class="flex-1 max-w-lg overflow-hidden">
                    <div class="text-xs text-gray-500 mb-1">Recent Words:</div>
                    <div id="wordHistory" class="flex gap-2 overflow-x-auto pb-1"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Rules Modal -->
    <div id="rulesModal" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-2xl p-6 max-w-lg mx-4 shadow-2xl max-h-[90vh] overflow-y-auto">
            <h2 class="text-3xl font-bold mb-4 game-font text-indigo-600">How to Play</h2>
            <div class="space-y-3 text-gray-700 text-sm">
                <div class="flex items-start gap-3">
                    <span class="bg-indigo-100 p-2 rounded-lg text-lg">üí£</span>
                    <div>
                        <h4 class="font-bold">The Bomb</h4>
                        <p>A bomb is passed between players. Each player must type a valid English word before the timer runs out!</p>
                    </div>
                </div>
                <div class="flex items-start gap-3">
                    <span class="bg-green-100 p-2 rounded-lg text-lg">üî§</span>
                    <div>
                        <h4 class="font-bold">Required Letters</h4>
                        <p>Your word MUST contain the displayed letter combination somewhere within it.</p>
                    </div>
                </div>
                <div class="flex items-start gap-3">
                    <span class="bg-yellow-100 p-2 rounded-lg text-lg">‚è±Ô∏è</span>
                    <div>
                        <h4 class="font-bold">Speeding Up!</h4>
                        <p>After every successful word, the timer decreases by 0.5 seconds! Time resets when someone loses a life.</p>
                    </div>
                </div>
                <div class="flex items-start gap-3">
                    <span class="bg-red-100 p-2 rounded-lg text-lg">‚ö†Ô∏è</span>
                    <div>
                        <h4 class="font-bold">Don't Repeat</h4>
                        <p>You cannot use words that have already been used in the current round!</p>
                    </div>
                </div>
                <div class="flex items-start gap-3">
                    <span class="bg-purple-100 p-2 rounded-lg text-lg">üåê</span>
                    <div>
                        <h4 class="font-bold">Multiplayer</h4>
                        <p>Create a room and share your Room Code with friends, or join their room using their Room Code!</p>
                    </div>
                </div>
            </div>
            <button onclick="hideRules()" class="mt-6 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-xl transition">
                Got it! Let's Play
            </button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden items-center justify-center backdrop-blur-md">
        <div class="bg-white rounded-3xl p-6 max-w-md mx-4 shadow-2xl text-center">
            <div class="text-5xl mb-3" id="gameOverEmoji">üèÜ</div>
            <h2 class="text-3xl font-bold mb-2 game-font" id="gameOverTitle">Game Over!</h2>
            <p class="text-gray-600 mb-4 text-sm" id="gameOverMessage">Someone won the game!</p>
            
            <div class="bg-gray-100 rounded-xl p-3 mb-4">
                <div class="text-sm text-gray-500 mb-2">Final Standings</div>
                <div id="finalStandings" class="space-y-1 text-sm"></div>
            </div>

            <button onclick="restartGame()" class="w-full bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 text-white font-bold py-3 rounded-xl shadow-lg transform hover:scale-105 transition-all">
                Play Again üîÑ
            </button>
        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            mode: 'single',
            players: [],
            currentPlayerIndex: 0,
            timeLeft: 10,
            maxTime: 10,
            baseTime: 10,
            currentBaseTime: 10,
            isPlaying: false,
            round: 1,
            usedWords: new Set(),
            currentLetters: '',
            difficulty: 'medium',
            timerInterval: null,
            bombFuse: 100,
            muted: false,
            roomCode: null,
            isHost: false,
            myPlayerId: 1,
            consecutiveSuccesses: 0
        };

        // Multiplayer state with PeerJS
        let multiplayerState = {
            peer: null,
            connections: [], // Array of DataConnection objects
            myPeerId: null,
            isHost: false,
            hostPeerId: null,
            connected: false,
            maxPlayers: 4,
            roomCode: null,
            roomPingInterval: null,
            hostConnection: null // For client: the connection to host
        };

        // Letter combinations
        const letterCombos = {
            easy: ['AT', 'AN', 'IN', 'ON', 'IT', 'IS', 'BE', 'TO', 'OF', 'AND', 'FOR', 'BUT', 'OR', 'UP', 'BY', 'ED', 'ER'],
            medium: ['ING', 'TION', 'ABLE', 'MENT', 'NESS', 'EST', 'LY', 'RE', 'UN', 'TH', 'CH', 'SH', 'GH', 'CK', 'EE', 'IST', 'QU'],
            hard: ['OUGH', 'IGHT', 'OULD', 'IOUS', 'EOUS', 'ATURE', 'ITION', 'EMENT', 'ANCE', 'ENCE', 'SION', 'ALLY', 'ICAL', 'TIAL']
        };

        const DATAMUSE_API = 'https://api.datamuse.com/words';

        // Audio setup
        let synth, bombTickSynth, explosionSynth, winSynth;
        let audioInitialized = false;

async function initAudio() {
    if (audioInitialized) return;
    await Tone.start();
    if (Tone.context.state !== 'running') {
        await Tone.context.resume();
    }
    
    // ADD THIS BACK:
    synth = new Tone.PolySynth(Tone.Synth).toDestination();
    synth.volume.value = -10;
    
    bombTickSynth = new Tone.MembraneSynth({
        pitchDecay: 0.05, octaves: 2, oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    bombTickSynth.volume.value = -5;
    
    explosionSynth = new Tone.NoiseSynth({
        noise: { type: 'brown' },
        envelope: { attack: 0.005, decay: 0.5, sustain: 0 }
    }).toDestination();
    explosionSynth.volume.value = -2;
    
    winSynth = new Tone.Synth({
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.05, decay: 0.5, sustain: 0.1, release: 1 }
    }).toDestination();
    winSynth.volume.value = -8;
    
    audioInitialized = true;
}

        function playTick() {
            if (gameState.muted || !audioInitialized) return;
            bombTickSynth.triggerAttackRelease("C2", "32n");
        }

        function playExplosion() {
            if (gameState.muted || !audioInitialized) return;
            explosionSynth.triggerAttackRelease("8n");
            const boom = new Tone.MembraneSynth().toDestination();
            boom.triggerAttackRelease("A1", "2n");
        }

        function playSuccess() {
            if (gameState.muted || !audioInitialized) return;
            synth.triggerAttackRelease(["C5", "E5", "G5"], "16n");
        }

        function playError() {
            if (gameState.muted || !audioInitialized) return;
            synth.triggerAttackRelease(["C3", "B2"], "16n");
        }

        function playWin() {
            if (gameState.muted || !audioInitialized) return;
            const now = Tone.now();
            winSynth.triggerAttackRelease("C4", "8n", now);
            winSynth.triggerAttackRelease("E4", "8n", now + 0.1);
            winSynth.triggerAttackRelease("G4", "8n", now + 0.2);
            winSynth.triggerAttackRelease("C5", "4n", now + 0.3);
        }

        function startAudio() {
            initAudio().then(() => {
                document.getElementById('audioStarter').style.display = 'none';
                document.getElementById('gameContainer').style.opacity = '1';
            });
        }

        function toggleMute() {
            gameState.muted = !gameState.muted;
            document.getElementById('muteBtn').textContent = gameState.muted ? 'üîá' : 'üîä';
        }

        function showRules() {
            document.getElementById('rulesModal').classList.remove('hidden');
            document.getElementById('rulesModal').classList.add('flex');
        }

        function hideRules() {
            document.getElementById('rulesModal').classList.add('hidden');
            document.getElementById('rulesModal').classList.remove('flex');
        }

function updateConnectionStatus(status, message) {
    const statusEl = document.getElementById('connectionStatus');
    const networkInfo = document.getElementById('networkInfo');
    const networkStatus = document.getElementById('networkStatus');
    
    if (!statusEl) return; // Add this line
    
    statusEl.classList.remove('hidden', 'status-connecting', 'status-connected', 'status-error', 'status-disconnected');
            
            switch(status) {
                case 'connecting':
                    statusEl.classList.add('status-connecting');
                    statusEl.textContent = message || 'Connecting...';
                    break;
                case 'connected':
                    statusEl.classList.add('status-connected');
                    statusEl.textContent = message || 'Connected';
                    if (networkInfo) networkInfo.classList.remove('hidden');
                    break;
                case 'error':
                    statusEl.classList.add('status-error');
                    statusEl.textContent = message || 'Error';
                    break;
                case 'disconnected':
                    statusEl.classList.add('status-disconnected');
                    statusEl.textContent = message || 'Disconnected';
                    break;
            }
            
            if (networkInfo && !networkInfo.classList.contains('hidden')) {
                networkStatus.textContent = message || status;
            }
        }

        // MULTIPLAYER FUNCTIONS - REAL PEER-TO-PEER
        function showMultiplayerOptions() {
            document.getElementById('multiplayerOptions').classList.remove('hidden');
        }

        function showCreateRoom() {
            document.getElementById('createRoomSection').classList.remove('hidden');
            document.getElementById('joinRoomSection').classList.add('hidden');
            initializeHost();
        }

        function showJoinRoom() {
            document.getElementById('joinRoomSection').classList.remove('hidden');
            document.getElementById('createRoomSection').classList.add('hidden');
            document.getElementById('roomCodeInput').focus();
        }

        // Generate a 6-digit room code
        function generateRoomCode() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }

        function initializeHost() {
            updateConnectionStatus('connecting', 'Initializing host...');
            
            // Generate 6-digit numeric code for display
            const roomCode = generateRoomCode();
            multiplayerState.roomCode = roomCode;
            
            // Create peer with auto-generated ID
            multiplayerState.peer = new Peer({config: {'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]}});
            multiplayerState.isHost = true;
            multiplayerState.connections = [];
            
            multiplayerState.peer.on('open', (id) => {
                multiplayerState.myPeerId = id;
                
                // Store room code -> peer ID mapping in localStorage for other tabs to find
                const roomData = {
                    peerId: id,
                    timestamp: Date.now(),
                    players: 1
                };
                localStorage.setItem(`wordbomb_room_${roomCode}`, JSON.stringify(roomData));
                
                // Also store in a global rooms list for discovery
                let activeRooms = JSON.parse(localStorage.getItem('wordbomb_active_rooms') || '[]');
                activeRooms.push({ code: roomCode, peerId: id, timestamp: Date.now() });
                // Keep only recent rooms (last 10 minutes)
                activeRooms = activeRooms.filter(r => Date.now() - r.timestamp < 600000);
                localStorage.setItem('wordbomb_active_rooms', JSON.stringify(activeRooms));
                
                document.getElementById('generatedRoomCode').textContent = roomCode;
                document.getElementById('peerIdDisplay').innerHTML = `
                    <div class="bg-blue-50 p-2 rounded mt-2 border border-blue-200">
                        <div class="text-xs text-blue-700 font-semibold">Room Code: <span class="text-lg font-bold">${roomCode}</span></div>
                        <div class="text-xs text-gray-500 mt-1">Share this 6-digit code with friends!</div>
                        <div class="text-xs text-gray-400 mt-1 font-mono">ID: ${id.substring(0, 12)}...</div>
                    </div>
                `;
                updateConnectionStatus('connected', `Host ready - Room: ${roomCode}`);
                updatePlayersInRoom(1);
                updateStartButton();
                
                // Keep the room data fresh while host is active
                multiplayerState.roomPingInterval = setInterval(() => {
                    const data = {
                        peerId: id,
                        timestamp: Date.now(),
                        players: multiplayerState.connections.length + 1
                    };
                    localStorage.setItem(`wordbomb_room_${roomCode}`, JSON.stringify(data));
                }, 5000);
            });
            
            multiplayerState.peer.on('connection', (conn) => {
                handleIncomingConnection(conn);
            });
            
            multiplayerState.peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateConnectionStatus('error', err.message);
            });
        }

        function updateStartButton() {
            const playerCount = multiplayerState.connections.length + 1;
            const startBtn = document.getElementById('startMultiBtn');
            const statusText = document.querySelector('#createRoomSection .text-xs.text-gray-500');
            
            if (playerCount >= 2 && playerCount <= 4) {
                startBtn.disabled = false;
                startBtn.textContent = `Start Game (${playerCount} players)`;
                if (statusText) statusText.textContent = 'Ready to start!';
            } else {
                startBtn.disabled = true;
                startBtn.textContent = 'Start Game';
                if (statusText) statusText.textContent = `Need ${2 - playerCount} more player${playerCount === 1 ? '' : 's'} to start`;
            }
        }

        function handleIncomingConnection(conn) {
            if (multiplayerState.connections.length >= multiplayerState.maxPlayers - 1) {
                conn.send({ type: 'error', message: 'Room is full' });
                conn.close();
                return;
            }
            
            conn.on('open', () => {
                multiplayerState.connections.push(conn);
                const playerCount = multiplayerState.connections.length + 1;
                updatePlayersInRoom(playerCount);
                updateConnectionStatus('connected', `Players: ${playerCount}/${multiplayerState.maxPlayers}`);
                updateStartButton();
                
                // Send current game state to new player
                conn.send({
                    type: 'playerInfo',
                    playerId: playerCount,
                    roomCode: multiplayerState.roomCode,
                    message: 'Welcome to the game!'
                });
                               
                // Broadcast player list update to all clients
                broadcastToClients({
                    type: 'playerJoined',
                    playerCount: playerCount,
                    maxPlayers: multiplayerState.maxPlayers
                });
                
                // Setup message handling
                conn.on('data', (data) => {
                    handleClientMessage(conn, data);
                });
                
                conn.on('close', () => {
                    // Remove connection
                    multiplayerState.connections = multiplayerState.connections.filter(c => c !== conn);
                    updatePlayersInRoom(multiplayerState.connections.length + 1);
                    updateStartButton();
                    broadcastToClients({
                        type: 'playerLeft',
                        playerCount: multiplayerState.connections.length + 1
                    });
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                });
            });
        }

function handleClientMessage(conn, data) {
    console.log('Received from client:', data);
    
    if (data.type === 'wordSubmitted') {
        handleRemoteWordSubmission(data.playerId, data.word);
    } else if (data.type === 'requestGameState') {
        if (!gameState.players || gameState.players.length === 0) {
            console.warn('Game not initialized yet');
            return;
        }
        // CRITICAL FIX: Send usedWords as array since Set doesn't serialize well
        conn.send({
            type: 'gameState',
            state: {
                ...gameState,
                usedWords: Array.from(gameState.usedWords)
            },
            players: gameState.players
        });
    }
}

        function broadcastToClients(data) {
            multiplayerState.connections.forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }

        function sendToHost(data) {
            if (!multiplayerState.isHost && multiplayerState.hostConnection && multiplayerState.hostConnection.open) {
                multiplayerState.hostConnection.send(data);
            }
        }

function copyRoomCode(event) {
    const code = document.getElementById('generatedRoomCode').textContent;
    navigator.clipboard.writeText(code).then(() => {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = originalText, 1500);
    });
}

        function updatePlayersInRoom(count) {
            document.getElementById('playersInRoom').textContent = `Players: ${count}/4`;
        }

        function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value.trim();
            const statusDiv = document.getElementById('joinStatus');
            
            if (!roomCode) {
                statusDiv.textContent = 'Please enter a Room Code';
                statusDiv.className = 'mt-2 text-sm text-center text-red-500 font-semibold';
                return;
            }
            
            if (roomCode.length !== 6 || !/^\d{6}$/.test(roomCode)) {
                statusDiv.textContent = 'Room Code must be 6 digits';
                statusDiv.className = 'mt-2 text-sm text-center text-red-500 font-semibold';
                return;
            }
            
            statusDiv.textContent = 'Looking up room...';
            statusDiv.className = 'mt-2 text-sm text-center text-blue-500';
            updateConnectionStatus('connecting', 'Finding room...');
            
            // Try to find room in localStorage first (works for same device)
            const roomData = localStorage.getItem(`wordbomb_room_${roomCode}`);
            
            if (roomData) {
                try {
                    const room = JSON.parse(roomData);
                    // Check if room is recent (less than 5 minutes old)
                    if (Date.now() - room.timestamp < 300000 && room.peerId) {
                        connectToHost(room.peerId, roomCode, statusDiv);
                        return;
                    } else {
                        statusDiv.textContent = 'Room expired or not found';
                    }
                } catch (e) {
                    console.error('Error parsing room data:', e);
                }
            }
            
            // If not found in localStorage, try the active rooms list
            const activeRooms = JSON.parse(localStorage.getItem('wordbomb_active_rooms') || '[]');
            const foundRoom = activeRooms.find(r => r.code === roomCode && Date.now() - r.timestamp < 300000);
            
            if (foundRoom && foundRoom.peerId) {
                connectToHost(foundRoom.peerId, roomCode, statusDiv);
                return;
            }
            
            // If still not found, show error and offer manual entry
            statusDiv.textContent = 'Room not found in this browser';
            statusDiv.className = 'mt-2 text-sm text-center text-orange-500 font-semibold';
            showManualPeerIdInput(roomCode, statusDiv);
        }

        function connectToHost(peerId, roomCode, statusDiv) {
            statusDiv.textContent = 'Connecting to host...';
            statusDiv.className = 'mt-2 text-sm text-center text-blue-500';
            
            multiplayerState.peer = new Peer({config: {'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]}});
            multiplayerState.isHost = false;
            multiplayerState.roomCode = roomCode;
            
            multiplayerState.peer.on('open', (id) => {
                multiplayerState.myPeerId = id;
                
                const conn = multiplayerState.peer.connect(peerId, {
                    reliable: true
                });
                
                const timeout = setTimeout(() => {
                    if (!conn.open) {
                        conn.close();
                        statusDiv.textContent = 'Connection timed out';
                        statusDiv.className = 'mt-2 text-sm text-center text-red-500 font-semibold';
                        showManualPeerIdInput(roomCode, statusDiv);
                    }
                }, 10000);
                
                conn.on('open', () => {
                    clearTimeout(timeout);
                    onSuccessfulConnection(conn, statusDiv);
                });
                
                conn.on('error', (err) => {
                    clearTimeout(timeout);
                    console.error('Connection error:', err);
                    statusDiv.textContent = 'Connection failed';
                    statusDiv.className = 'mt-2 text-sm text-center text-red-500 font-semibold';
                    showManualPeerIdInput(roomCode, statusDiv);
                });
            });
            
            multiplayerState.peer.on('error', (err) => {
                console.error('Peer error:', err);
                statusDiv.textContent = 'Error: ' + err.message;
                statusDiv.className = 'mt-2 text-sm text-center text-red-500 font-semibold';
            });
        }

        function showManualPeerIdInput(roomCode, statusDiv) {
            // Remove any existing manual input
            const existing = document.getElementById('manualConnectDiv');
            if (existing) existing.remove();
            
            const manualDiv = document.createElement('div');
            manualDiv.id = 'manualConnectDiv';
            manualDiv.className = 'mt-3 p-3 bg-yellow-50 rounded-lg border border-yellow-200';
            manualDiv.innerHTML = `
                <div class="text-xs text-yellow-800 mb-2">
                    <strong>Room not found automatically.</strong><br>
                    Ask the host to copy their full Peer ID and paste it below:
                </div>
                <input type="text" id="manualPeerId" placeholder="Paste Host Peer ID here..." 
                    class="w-full px-3 py-2 text-sm border border-yellow-300 rounded-lg mb-2 font-mono text-xs">
                <button id="manualConnectBtn" class="w-full py-2 bg-yellow-500 text-white rounded-lg text-sm font-bold hover:bg-yellow-600">Connect Directly</button>
                <div class="text-xs text-gray-500 mt-2">
                    <strong>Why?</strong> Room codes only work on the same device. 
                    For different devices, you need the full Peer ID.
                </div>
            `;
            
            statusDiv.parentNode.insertBefore(manualDiv, statusDiv.nextSibling);
            
            document.getElementById('manualConnectBtn').addEventListener('click', () => {
                const manualId = document.getElementById('manualPeerId').value.trim();
                if (manualId) {
                    manualDiv.remove();
                    connectToHost(manualId, roomCode, statusDiv);
                }
            });
        }

        function onSuccessfulConnection(conn, statusDiv) {
            multiplayerState.hostConnection = conn;
            multiplayerState.connections = [conn];
            statusDiv.textContent = 'Connected! Waiting for host to start...';
            statusDiv.className = 'mt-2 text-sm text-center text-green-600 font-bold';
            updateConnectionStatus('connected', 'Connected to room');
            
            // Listen for game start
            conn.on('data', (data) => {
                handleHostMessage(data);
            });
            
            conn.on('close', () => {
                updateConnectionStatus('disconnected', 'Disconnected from host');
                statusDiv.textContent = 'Disconnected';
                statusDiv.className = 'mt-2 text-sm text-center text-red-500';
                if (gameState.isPlaying) {
                    showMessage('Host disconnected!', 'error');
                    setTimeout(returnToHome, 2000);
                }
            });
        }

        function handleHostMessage(data) {
            console.log('Received from host:', data);
            
            if (data.type === 'gameStart') {
                // Validate that we received proper player data
                if (!data.players || data.players.length < 2) {
                    console.error('Invalid game data received:', data);
                    showMessage('Error: Invalid game data received', 'error');
                    return;
                }
                
                // Host started the game
                gameState.players = data.players.map(p => ({
                    ...p,
                    health: p.health || 3  // Ensure health is set
                }));
                gameState.myPlayerId = data.yourPlayerId;
                gameState.mode = 'multi';
                gameState.isHost = false;
                gameState.roomCode = multiplayerState.roomCode;
                
                document.getElementById('modeIndicator').textContent = `Multiplayer - Room: ${gameState.roomCode}`;
                document.getElementById('homeBtn').classList.remove('hidden');
                document.getElementById('homePanel').classList.remove('active');
                document.getElementById('gamePanel').classList.add('active');
                
                startGame();
            } else if (data.type === 'gameState') {
                // Update game state - but only if game is already playing
                if (gameState.isPlaying && data.state) {
                    const currentInterval = gameState.timerInterval;
                    
                    // CRITICAL FIX: Convert usedWords back to Set if it's an array
                    let usedWords = data.state.usedWords;
                    if (Array.isArray(usedWords)) {
                        usedWords = new Set(usedWords);
                    } else if (!usedWords) {
                        usedWords = new Set();
                    }
                    
                    gameState = { 
                        ...gameState, 
                        ...data.state,
                        usedWords: usedWords,
                        timerInterval: currentInterval,
                        players: data.players || data.state.players || gameState.players
                    };
                    
                    if (gameState.players) {
                        gameState.players = gameState.players.map(p => ({
                            ...p,
                            health: typeof p.health === 'number' ? p.health : 3
                        }));
                    }
                    updatePlayersDisplay();
                    updateTimerDisplay();
                    updateLettersDisplay();
                    updateBaseTimeDisplay();
                    // Update word history display
                    document.getElementById('wordHistory').innerHTML = '';
                    gameState.usedWords.forEach(word => addToHistory(word, false));
                }
            } else if (data.type === 'turnUpdate') {
                gameState.currentPlayerIndex = data.currentPlayerIndex;
                gameState.timeLeft = data.timeLeft;
                gameState.maxTime = data.maxTime || gameState.maxTime;
                gameState.currentLetters = data.currentLetters;
                
                // CRITICAL FIX: Always clear existing timer before starting new one
                clearInterval(gameState.timerInterval);
                
                // Only start local timer if game is still playing
                if (gameState.isPlaying) {
                    gameState.timerInterval = setInterval(() => {
                        if (gameState.isPlaying && gameState.timeLeft > 0) {
                            gameState.timeLeft = Math.max(0, gameState.timeLeft - 0.1);
                            updateTimerDisplay();
                            updateFuse();
                            
                            // Sync tick sound with visual
                            const timeInt = Math.floor(gameState.timeLeft * 10);
                            if (timeInt % 10 === 0 && gameState.timeLeft > 0 && gameState.timeLeft < gameState.maxTime) {
                                playTick();
                            }
                            
                            const bomb = document.querySelector('.bomb-container');
                            if (gameState.timeLeft <= 3) bomb.classList.add('pulse-red');
                            else bomb.classList.remove('pulse-red');
                        }
                    }, 100);
                }
                
                updatePlayersDisplay();
                updateTimerDisplay();
                updateLettersDisplay();
                updateInputState();
            } else if (data.type === 'wordValidation') {
                // Host validated a word
                document.getElementById('validationStatus').innerHTML = '';
                document.getElementById('submitBtn').disabled = false;
                
                if (data.valid) {
                    gameState.usedWords.add(data.word.toUpperCase());
                    gameState.currentBaseTime = data.newBaseTime;
                    updateBaseTimeDisplay();
                    addToHistory(data.word.toUpperCase(), data.offline || false);
                    // Clear input on success
                    document.getElementById('wordInput').value = '';
                } else {
                    // CRITICAL FIX: Handle invalid word response
                    playError();
                    showMessage(data.reason || 'Invalid word!', 'error');
                    const input = document.getElementById('wordInput');
                    input.classList.add('shake');
                    setTimeout(() => input.classList.remove('shake'), 500);
                    // Don't clear input so they can try again
                }
            } else if (data.type === 'playerEliminated') {
                const player = gameState.players.find(p => p.id === data.playerId);
                if (player) {
                    player.health = 0;
                    updatePlayersDisplay();
                }
            } else if (data.type === 'playerHealthUpdate') {
                const player = gameState.players.find(p => p.id === data.playerId);
                if (player) {
                    player.health = data.health;
                    updatePlayersDisplay();
                    if (player.health <= 0) {
                        showMessage(`${player.name} eliminated!`, 'error');
                    }
                }
            } else if (data.type === 'gameOver') {
                clearInterval(gameState.timerInterval); // CRITICAL: Client stops timer
                // Update final player states if provided
                if (data.finalPlayers) {
                    gameState.players = data.finalPlayers;
                }
                const winner = gameState.players.find(p => p.id === data.winnerId);
                endGame(winner);
            } else if (data.type === 'bombExploded') {
                // Sync explosion effects
                playExplosion();
                gameState.consecutiveSuccesses = 0;
                gameState.currentBaseTime = data.newBaseTime;
                updateBaseTimeDisplay();
            }
        }

function handleRemoteWordSubmission(playerId, word) {
    if (!gameState.isPlaying) return;
    
    validateWordWithAPI(word).then(validation => {
        const isValid = validation.valid && word.toUpperCase().includes(gameState.currentLetters);
        const newBaseTime = Math.max(3, gameState.currentBaseTime - 0.5);
        
        // CRITICAL FIX: Always send validation result back to client
        const conn = multiplayerState.connections.find(c => c.peer === gameState.players.find(p => p.id === playerId)?.peerId);
        if (conn && conn.open) {
            conn.send({
                type: 'wordValidation',
                playerId: playerId,
                word: word,
                valid: isValid,
                offline: validation.offline || false,
                newBaseTime: newBaseTime,
                reason: isValid ? 'success' : (validation.valid ? `Missing letters ${gameState.currentLetters}` : 'Invalid word')
            });
        }
        
        if (isValid) {
            gameState.usedWords.add(word.toUpperCase());
            gameState.currentBaseTime = newBaseTime;
            updateBaseTimeDisplay();
            addToHistory(word.toUpperCase(), validation.offline || false);
            
            clearInterval(gameState.timerInterval);
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            setTimeout(nextTurn, 1500);
        }
    });
}

        function closeRoom() {
            // Clear the ping interval
            if (multiplayerState.roomPingInterval) {
                clearInterval(multiplayerState.roomPingInterval);
            }
            
            // Remove room from localStorage
            if (multiplayerState.roomCode) {
                localStorage.removeItem(`wordbomb_room_${multiplayerState.roomCode}`);
                
                // Remove from active rooms list
                let activeRooms = JSON.parse(localStorage.getItem('wordbomb_active_rooms') || '[]');
                activeRooms = activeRooms.filter(r => r.code !== multiplayerState.roomCode);
                localStorage.setItem('wordbomb_active_rooms', JSON.stringify(activeRooms));
            }
            
            // Close all connections and destroy peer
            if (multiplayerState.peer) {
                multiplayerState.connections.forEach(conn => conn.close());
                multiplayerState.peer.destroy();
            }
            multiplayerState = {
                peer: null, connections: [], myPeerId: null,
                isHost: false, hostPeerId: null, connected: false, maxPlayers: 4, roomCode: null,
                roomPingInterval: null, hostConnection: null
            };
            
            document.getElementById('createRoomSection').classList.add('hidden');
            document.getElementById('generatedRoomCode').textContent = '------';
            updateConnectionStatus('disconnected');
            updatePlayersInRoom(1);
        }

        function cancelJoin() {
            if (multiplayerState.peer) {
                multiplayerState.peer.destroy();
            }
            multiplayerState = {
                peer: null, connections: [], myPeerId: null,
                isHost: false, hostPeerId: null, connected: false, maxPlayers: 4, roomCode: null,
                roomPingInterval: null, hostConnection: null
            };
            document.getElementById('joinRoomSection').classList.add('hidden');
            document.getElementById('joinStatus').textContent = '';
            updateConnectionStatus('disconnected');
        }

        function returnToHome() {
            gameState.isPlaying = false;
            clearInterval(gameState.timerInterval);
            
            // Disconnect multiplayer if active
            if (multiplayerState.peer) {
                multiplayerState.connections.forEach(conn => conn.close());
                multiplayerState.peer.destroy();
                multiplayerState = {
                    peer: null, connections: [], myPeerId: null,
                    isHost: false, hostPeerId: null, connected: false, maxPlayers: 4, roomCode: null,
                    roomPingInterval: null, hostConnection: null
                };
            }
            
            document.getElementById('homePanel').classList.add('active');
            document.getElementById('gamePanel').classList.remove('active');
            document.getElementById('homeBtn').classList.add('hidden');
            document.getElementById('modeIndicator').textContent = 'Select a mode';
            document.getElementById('connectionStatus').classList.add('hidden');
            document.getElementById('multiplayerOptions').classList.add('hidden');
            document.getElementById('createRoomSection').classList.add('hidden');
            document.getElementById('joinRoomSection').classList.add('hidden');
        }

        function startSinglePlayer() {
    gameState.mode = 'single';
    gameState.isHost = true;  // Single player acts as host
    gameState.myPlayerId = 1;
            
            gameState.players = [
                { id: 1, name: 'You', health: 3, isBot: false, avatar: 'üòé', color: 'bg-blue-500', isLocal: true },
                { id: 2, name: 'Bot 1', health: 3, isBot: true, avatar: 'ü§ñ', color: 'bg-red-500', isLocal: false },
                { id: 3, name: 'Bot 2', health: 3, isBot: true, avatar: 'üëæ', color: 'bg-green-500', isLocal: false },
                { id: 4, name: 'Bot 3', health: 3, isBot: true, avatar: 'üéÉ', color: 'bg-purple-500', isLocal: false }
            ];
            
            document.getElementById('modeIndicator').textContent = 'Single Player Mode';
            document.getElementById('homeBtn').classList.remove('hidden');
            startGame();
        }

        function startMultiplayerGame() {
            if (!multiplayerState.isHost) return;
            
            const playerCount = multiplayerState.connections.length + 1;
            if (playerCount < 2) {
                showMessage('Need at least 2 players to start!', 'error');
                return;
            }
            
            gameState.mode = 'multi';
            gameState.isHost = true;
            gameState.myPlayerId = 1;
            gameState.roomCode = multiplayerState.roomCode;
            
            // Build player list - ONLY REAL PLAYERS, NO BOTS EVER
            gameState.players = [
                { id: 1, name: 'You (Host)', health: 3, isBot: false, avatar: 'üëë', color: 'bg-yellow-500', isLocal: true }
            ];
            
            // Add ONLY connected clients as players - NO BOTS
            multiplayerState.connections.forEach((conn, index) => {
                gameState.players.push({
                    id: index + 2,
                    name: `Player ${index + 2}`,
                    health: 3,
                    isBot: false,
                    avatar: ['üéÆ', 'üéØ', 'üé™'][index] || 'üë§',
                    color: ['bg-blue-500', 'bg-green-500', 'bg-purple-500'][index] || 'bg-gray-500',
                    isLocal: false,
                    peerId: conn.peer
                });
            });
            
            // Final check to ensure we have all players before starting
            if (gameState.players.length < 2) {
                showMessage('Error: Player list incomplete', 'error');
                return;
            }
            
            // NO BOT FILLING - Game starts with however many real players joined (2-4)
            
            // Notify all clients that game is starting
            multiplayerState.connections.forEach((conn, index) => {
                conn.send({
                    type: 'gameStart',
                    players: gameState.players,
                    yourPlayerId: index + 2
                });
            });
            
            document.getElementById('modeIndicator').textContent = `Multiplayer - Room: ${gameState.roomCode} (${gameState.players.length} players)`;
            document.getElementById('homeBtn').classList.remove('hidden');
            document.getElementById('homePanel').classList.remove('active');
            document.getElementById('gamePanel').classList.add('active');
            
            startGame();
        }

        async function validateWordWithAPI(word) {
            try {
                const response = await fetch(`${DATAMUSE_API}?sp=${word.toLowerCase()}&md=d&max=1`);
                
                if (!response.ok) throw new Error('API request failed');
                
                const data = await response.json();
                
                if (data.length > 0 && data[0].word.toLowerCase() === word.toLowerCase()) {
                    return { valid: true, wordData: data[0], source: 'datamuse' };
                }
                
                return { valid: false, reason: 'Word not found in dictionary', source: 'datamuse' };
                
            } catch (error) {
                console.error('API Error:', error);
                return { valid: true, offline: true, reason: 'API unavailable - accepting word in offline mode', source: 'fallback' };
            }
        }

        async function getWordsWithLetters(letters) {
            try {
                const response = await fetch(`${DATAMUSE_API}?sp=*${letters.toLowerCase()}*&md=f&max=50`);
                
                if (!response.ok) throw new Error('API request failed');
                
                const data = await response.json();
                
                return data
                    .filter(w => {
                        const word = w.word.toUpperCase();
                        return word.length >= 3 && 
                               word.includes(letters.toUpperCase()) &&
                               !gameState.usedWords.has(word) &&
                               !word.includes(' ') &&
                               !word.includes('-');
                    })
                    .map(w => w.word.toUpperCase())
                    .slice(0, 20);
                    
            } catch (error) {
                console.error('Bot word generation error:', error);
                return [];
            }
        }

        // Game Functions
        function startGame() {
            document.getElementById('homePanel').classList.remove('active');
            document.getElementById('gamePanel').classList.add('active');
            
            gameState.isPlaying = true;
            gameState.round = 1;
            gameState.usedWords.clear();
            
            // Ensure all players have valid health
            if (!gameState.players || gameState.players.length === 0) {
                console.error('No players in game state!');
                return;
            }
            
            gameState.players.forEach(p => {
                if (p) p.health = 3;
            });
            
            gameState.currentPlayerIndex = 0;
            
            gameState.consecutiveSuccesses = 0;
const difficulties = ['easy', 'medium', 'hard'];
gameState.difficulty = difficulties[Math.floor(Math.random() * difficulties.length)];

const baseDifficultyTime = gameState.difficulty === 'easy' ? 15 : gameState.difficulty === 'medium' ? 12 : 10;
gameState.baseTime = baseDifficultyTime;
gameState.currentBaseTime = baseDifficultyTime;
            
            updatePlayersDisplay();
            updateBaseTimeDisplay();
            nextTurn();
        }

function nextTurn() {
    if (!gameState.isPlaying) return;
    
    // Safety check: ensure we have players
    if (!gameState.players || gameState.players.length === 0) {
        console.error('No players available in nextTurn');
        return;
    }
    
    // CLIENT MODE: Just update UI, don't control game flow
    if (gameState.mode === 'multi' && !gameState.isHost) {
        updatePlayersDisplay();
        updateTimerDisplay();
        updateLettersDisplay();
        updateInputState();
        return;
    }
    
    const alivePlayers = gameState.players.filter(p => p && p.health > 0);
            
            if (alivePlayers.length === 1) {
                endGame(alivePlayers[0]);
                return;
            }
            
            if (alivePlayers.length === 0) {
                endGame(null);
                return;
            }
            
            // Find next alive player
            let attempts = 0;
            while (attempts < gameState.players.length) {
                const player = gameState.players[gameState.currentPlayerIndex];
                if (player && player.health > 0) break;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                attempts++;
            }
            
            const player = gameState.players[gameState.currentPlayerIndex];
            
            if (!player) {
                console.error('Current player is undefined');
                return;
            }
            
            generateLetters();
            
            gameState.maxTime = gameState.currentBaseTime;
            gameState.timeLeft = gameState.maxTime;
            
            updateTimerDisplay();
            updateLettersDisplay();
            updatePlayersDisplay();
            updateInputState();
            
            // Only host or single player handles bot turns and timer
            if (gameState.mode === 'single' || gameState.isHost) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = setInterval(gameLoop, 100);
                
                if (player.isBot) {
                    setTimeout(() => botPlay(), 2000);
                }
            }
            
            // Sync turn to all clients in multiplayer (only host broadcasts)
            if (gameState.mode === 'multi' && gameState.isHost) {
                broadcastToClients({
                    type: 'turnUpdate',
                    currentPlayerIndex: gameState.currentPlayerIndex,
                    timeLeft: gameState.timeLeft,
                    maxTime: gameState.maxTime,
                    currentLetters: gameState.currentLetters
                });
            }
            
            showMessage(`${player.name}'s turn!`, 'info');
        }

function updateInputState() {
    const input = document.getElementById('wordInput');
    const submitBtn = document.getElementById('submitBtn');
    const player = gameState.players[gameState.currentPlayerIndex];
    
    if (!player) return;
    
    const isMyTurn = (gameState.mode === 'single' && !player.isBot) || 
                    (gameState.mode === 'multi' && player.id === gameState.myPlayerId);
    
    // CRITICAL FIX: Force input state update
    if (!isMyTurn) {
        input.disabled = true;
        submitBtn.disabled = true;
        input.placeholder = `${player.name}'s turn...`;
        input.value = '';
        input.blur(); // Remove focus
        document.getElementById('validationStatus').innerHTML = '';
    } else {
        input.disabled = false;
        submitBtn.disabled = false;
        input.placeholder = 'TYPE WORD HERE...';
        input.value = '';
        // Small delay to ensure focus works after state updates
        setTimeout(() => {
            if (gameState.isPlaying && !input.disabled) {
                input.focus();
            }
        }, 50);
        document.getElementById('validationStatus').innerHTML = '';
    }
}

function generateLetters() {
    const difficulties = ['easy', 'medium', 'hard'];
    // Randomly pick difficulty for each turn
    const randomDiff = difficulties[Math.floor(Math.random() * difficulties.length)];
    gameState.difficulty = randomDiff;

    const pool = letterCombos[randomDiff];
    gameState.currentLetters = pool[Math.floor(Math.random() * pool.length)];
}

        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            gameState.timeLeft -= 0.1;
            updateTimerDisplay();
            updateFuse();
            
            if (Math.floor(gameState.timeLeft * 10) % 10 === 0 && gameState.timeLeft > 0) {
                playTick();
            }
            
            const bomb = document.querySelector('.bomb-container');
            if (gameState.timeLeft <= 3) bomb.classList.add('pulse-red');
            else bomb.classList.remove('pulse-red');
            
            if (gameState.timeLeft <= 0) bombExploded();
        }

        function updateFuse() {
            const percentage = (gameState.timeLeft / gameState.maxTime) * 100;
            const fuse = document.getElementById('fuse');
            const spark = document.getElementById('spark');
            
            fuse.style.height = `${30 * (percentage / 100)}px`;
            spark.style.top = `${-25 + (30 * (1 - percentage / 100))}px`;
            
            if (percentage > 60) fuse.style.background = '#10b981';
            else if (percentage > 30) fuse.style.background = '#f59e0b';
            else fuse.style.background = '#ef4444';
        }

function bombExploded() {
    clearInterval(gameState.timerInterval);
    playExplosion();
    
    const player = gameState.players[gameState.currentPlayerIndex];
    if (player) {
        player.health--;
    }
    
    gameState.consecutiveSuccesses = 0;
    
    // Randomize difficulty on explosion reset as well
    const difficulties = ['easy', 'medium', 'hard'];
    gameState.difficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
    
    const baseDifficultyTime = gameState.difficulty === 'easy' ? 15 : gameState.difficulty === 'medium' ? 12 : 10;
    gameState.currentBaseTime = baseDifficultyTime;
    updateBaseTimeDisplay();
            
            const explosion = document.getElementById('explosion');
            explosion.classList.add('explode-animation');
            document.getElementById('gameContainer').classList.add('shake');
            
            const playerName = player ? player.name : 'Someone';
            showMessage(`BOOM! Timer reset! ${playerName} lost a heart!`, 'error');
            
            // Sync explosion to all clients
            if (gameState.mode === 'multi' && gameState.isHost) {
                broadcastToClients({
                    type: 'bombExploded',
                    playerId: player ? player.id : null,
                    newBaseTime: gameState.currentBaseTime
                });
            }
            
            // Sync elimination to all clients
            if (gameState.mode === 'multi' && gameState.isHost && player) {
                broadcastToClients({
                    type: 'playerHealthUpdate',
                    playerId: player.id,
                    health: player.health
                });
            }
            
            setTimeout(() => {
                explosion.classList.remove('explode-animation');
                document.getElementById('gameContainer').classList.remove('shake');
                
                if (player && player.health <= 0) {
                    showMessage(`${player.name} eliminated!`, 'error');
                    if (gameState.mode === 'multi' && gameState.isHost) {
                        broadcastToClients({
                            type: 'playerEliminated',
                            playerId: player.id
                        });
                    }
                }
                
                gameState.round++;
                document.getElementById('roundDisplay').textContent = gameState.round;
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                nextTurn();
            }, 1000);
        }

        async function submitWord() {
            const input = document.getElementById('wordInput');
            const word = input.value.trim().toUpperCase();
            
            if (!word) return;
            
            if (word.length < 3) {
                showMessage('Word must be at least 3 letters!', 'error');
                playError();
                input.classList.add('shake');
                input.value = '';
                setTimeout(() => input.classList.remove('shake'), 500);
                return;
            }
            
            if (!word.includes(gameState.currentLetters)) {
                showMessage(`Word must contain "${gameState.currentLetters}"!`, 'error');
                playError();
                input.classList.add('shake');
                input.value = '';
                setTimeout(() => input.classList.remove('shake'), 500);
                return;
            }
            
            if (gameState.usedWords.has(word)) {
                showMessage('Word already used!', 'error');
                playError();
                input.classList.add('shake');
                input.value = '';
                setTimeout(() => input.classList.remove('shake'), 500);
                return;
            }
            
            document.getElementById('validationStatus').innerHTML = '<div class="loading-spinner"></div>';
            document.getElementById('submitBtn').disabled = true;
            
            // In multiplayer, send word to host for validation if not host
            if (gameState.mode === 'multi' && !gameState.isHost) {
                sendToHost({
                    type: 'wordSubmitted',
                    playerId: gameState.myPlayerId,
                    word: word
                });
                // Wait for host validation response
                setTimeout(() => {
                    document.getElementById('validationStatus').innerHTML = '';
                    document.getElementById('submitBtn').disabled = false;
                    // Clear input after submission
                    input.value = '';
                }, 1000);
                return;
            }
            
            const validation = await validateWordWithAPI(word);
            
            document.getElementById('validationStatus').innerHTML = '';
            document.getElementById('submitBtn').disabled = false;
            
            if (!validation.valid) {
                showMessage(`"${word}" is not a valid English word!`, 'error');
                playError();
                input.classList.add('shake');
                input.value = '';
                setTimeout(() => input.classList.remove('shake'), 500);
                return;
            }
            
            // Success
            playSuccess();
            gameState.usedWords.add(word);
            addToHistory(word, validation.source === 'fallback');
            
            gameState.consecutiveSuccesses++;
            gameState.currentBaseTime = Math.max(3, gameState.currentBaseTime - 0.5);
            updateBaseTimeDisplay();
            
            clearInterval(gameState.timerInterval);
            
            if (validation.offline) showMessage(`Great word! Time decreased to ${gameState.currentBaseTime.toFixed(1)}s!`, 'warning');
            else showMessage(`Great word! Time decreased to ${gameState.currentBaseTime.toFixed(1)}s!`, 'success');
            
            input.value = '';
            
            // Move to next player
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            setTimeout(nextTurn, 1500);
        }

        function updateBaseTimeDisplay() {
            document.getElementById('baseTimeDisplay').textContent = `Next player: ${gameState.currentBaseTime.toFixed(1)}s`;
        }

        async function botPlay() {
            if (!gameState.isPlaying) return;
            
            // Don't run bots in multiplayer unless we're the host
            if (gameState.mode === 'multi' && !gameState.isHost) return;
            
            document.getElementById('validationStatus').innerHTML = '<div class="loading-spinner"></div>';
            
            const possibleWords = await getWordsWithLetters(gameState.currentLetters);
            
            document.getElementById('validationStatus').innerHTML = '';
            
            const player = gameState.players[gameState.currentPlayerIndex];
            if (!player || !player.isBot) return;
            
            const accuracy = player.health > 1 ? 0.85 : 0.6;
            
            if (possibleWords.length > 0 && Math.random() < accuracy) {
                const word = possibleWords[Math.floor(Math.random() * Math.min(possibleWords.length, 5))];
                const input = document.getElementById('wordInput');
                
                let currentIndex = 0;
                const typeInterval = setInterval(() => {
                    if (!gameState.isPlaying) {
                        clearInterval(typeInterval);
                        return;
                    }
                    if (currentIndex <= word.length) {
                        input.value = word.substring(0, currentIndex);
                        currentIndex++;
                    } else {
                        clearInterval(typeInterval);
                        setTimeout(() => submitWord(), 300);
                    }
                }, 100 + Math.random() * 50);
            } else {
                const input = document.getElementById('wordInput');
                input.value = 'thinking...';
                setTimeout(() => {
                    if (gameState.isPlaying) {
                        input.value = '';
                    }
                }, 1000);
            }
        }

function endGame(winner) {
    gameState.isPlaying = false;
    clearInterval(gameState.timerInterval); // CRITICAL: Stop timer immediately
    
    // Broadcast game over to all clients
    if (gameState.mode === 'multi' && gameState.isHost) {
        broadcastToClients({
            type: 'gameOver',
            winnerId: winner ? winner.id : null,
            finalPlayers: gameState.players // Send final state
        });
    }
    
    playWin();
    
    document.getElementById('gameOverModal').classList.remove('hidden');
    document.getElementById('gameOverModal').classList.add('flex');
    
    const isMe = winner && winner.id === gameState.myPlayerId;
    document.getElementById('gameOverTitle').textContent = isMe ? 'You Win!' : 'Game Over!';
    document.getElementById('gameOverEmoji').textContent = isMe ? 'üèÜ' : 'üéÆ';
    
    if (winner && winner.name) {
        document.getElementById('gameOverMessage').textContent = isMe ? 
            'Congratulations! You are the Word Bomb champion!' : 
            `${winner.name} won the game!`;
    } else {
        document.getElementById('gameOverMessage').textContent = 'Game ended in a draw!';
    }
    
    // Safely generate standings
    let standingsHTML = '';
    if (gameState.players && gameState.players.length > 0) {
        const validPlayers = gameState.players.filter(p => p && typeof p === 'object');
        const sortedPlayers = validPlayers.sort((a, b) => (b.health || 0) - (a.health || 0));
        
        standingsHTML = sortedPlayers.map((p, i) => {
            const avatar = p.avatar || 'üë§';
            const name = p.name || `Player ${p.id || i + 1}`;
            const health = Math.max(0, Math.min(3, p.health || 0));
            const isCurrentPlayer = p.id === gameState.myPlayerId;
            const isWinner = winner && p.id === winner.id;
            
            return `
                <div class="flex items-center justify-between p-2 ${isWinner ? 'bg-yellow-100 rounded-lg' : ''}">
                    <div class="flex items-center gap-2">
                        <span>${isWinner ? 'üëë' : `${i + 1}.`}</span>
                        <span class="text-xl">${avatar}</span>
                        <span class="font-bold ${isCurrentPlayer ? 'text-indigo-600' : 'text-gray-700'}">${name}</span>
                        ${isCurrentPlayer ? '<span class="text-xs bg-indigo-100 text-indigo-800 px-1 rounded">You</span>' : ''}
                    </div>
                    <div class="flex items-center gap-1">
                        ${'‚ù§Ô∏è'.repeat(health)}${'üñ§'.repeat(3 - health)}
                    </div>
                </div>
            `;
        }).join('');
    } else {
        standingsHTML = '<div class="text-gray-500 text-center">No players</div>';
    }
    
    document.getElementById('finalStandings').innerHTML = standingsHTML;
}

        function restartGame() {
            document.getElementById('gameOverModal').classList.add('hidden');
            document.getElementById('gameOverModal').classList.remove('flex');
            
            // Reset game state
            gameState.usedWords.clear();
            gameState.round = 1;
            gameState.difficulty = 'medium';
            gameState.currentBaseTime = 10;
            gameState.consecutiveSuccesses = 0;
            
            if (gameState.mode === 'single') {
                startSinglePlayer();
            } else {
                // In multiplayer, only host can restart
                if (gameState.isHost) {
                    // Reset all player health
                    gameState.players.forEach(p => {
                        if (p) p.health = 3;
                    });
                    startMultiplayerGame();
                } else {
                    // Client returns to lobby waiting for host
                    showMessage('Waiting for host to restart...', 'info');
                    document.getElementById('homePanel').classList.add('active');
                    document.getElementById('gamePanel').classList.remove('active');
                }
            }
        }

        // UI Update Functions
        function updatePlayersDisplay() {
            const container = document.getElementById('playersList');
            if (!gameState.players) return;
            
            container.innerHTML = gameState.players.map((player, index) => {
                if (!player) return '';
                const isCurrentPlayer = index === gameState.currentPlayerIndex;
                const isMe = player.id === gameState.myPlayerId;
                const isDead = player.health <= 0;
                
                return `
                    <div class="flex items-center gap-2 p-2 bg-white rounded-xl shadow-sm ${isCurrentPlayer ? 'ring-2 ring-indigo-500' : ''} ${isDead ? 'opacity-50' : ''}">
                        <div class="player-avatar ${player.color || 'bg-gray-500'} text-white ${isCurrentPlayer ? 'player-active' : ''} ${isDead ? 'player-dead' : ''}">
                            ${player.avatar || 'üë§'}
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="flex justify-between items-center">
                                <span class="font-bold text-sm ${isMe ? 'text-indigo-600' : 'text-gray-700'} truncate">${player.name || 'Unknown'}</span>
                                ${isMe ? '<span class="text-xs bg-indigo-100 text-indigo-800 px-1 rounded">You</span>' : ''}
                            </div>
                            <div class="flex gap-1 mt-1">
                                ${Array(3).fill(0).map((_, i) => `
                                    <div class="w-4 h-1.5 rounded-full ${i < (player.health || 0) ? 'bg-red-500' : 'bg-gray-200'}"></div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateTimerDisplay() {
            const timer = document.getElementById('timerDisplay');
            const timeLeft = Math.max(0, gameState.timeLeft);
            timer.textContent = timeLeft.toFixed(2);
            
            // Remove all color classes first
            timer.classList.remove('text-gray-800', 'text-yellow-500', 'text-red-500');
            
            if (timeLeft > 5) timer.classList.add('text-gray-800');
            else if (timeLeft > 2) timer.classList.add('text-yellow-500');
            else timer.classList.add('text-red-500');
        }

        function updateLettersDisplay() {
            const container = document.getElementById('lettersContainer');
            const letters = (gameState.currentLetters || '').split('');
            
            container.innerHTML = letters.map(letter => `
                <div class="letter-card w-12 h-14 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center text-white text-xl font-bold game-font shadow-lg">
                    ${letter}
                </div>
            `).join('');
            
            const diffElement = document.getElementById('difficultyIndicator');
            const diffText = gameState.difficulty ? gameState.difficulty.charAt(0).toUpperCase() + gameState.difficulty.slice(1) : 'Medium';
            diffElement.textContent = `${diffText} Difficulty`;
            diffElement.className = `text-center mt-2 text-xs font-bold difficulty-${gameState.difficulty || 'medium'}`;
        }

        function addToHistory(word, isOffline) {
            const history = document.getElementById('wordHistory');
            const item = document.createElement('div');
            item.className = 'word-history-item flex-shrink-0 px-2 py-1 bg-indigo-100 text-indigo-800 rounded-full text-xs font-semibold flex items-center gap-1';
            item.innerHTML = `${word} ${isOffline ? '<span class="text-xs">‚ö†Ô∏è</span>' : ''}`;
            history.insertBefore(item, history.firstChild);
            
            while (history.children.length > 10) {
                history.removeChild(history.lastChild);
            }
            
            document.getElementById('wordsUsedDisplay').textContent = gameState.usedWords.size;
        }

        function showMessage(text, type) {
            const display = document.getElementById('messageDisplay');
            display.textContent = text;
            
            // Remove all color classes
            display.classList.remove('text-red-500', 'text-green-500', 'text-yellow-500', 'text-indigo-600');
            
            // Add appropriate color
            if (type === 'error') display.classList.add('text-red-500');
            else if (type === 'success') display.classList.add('text-green-500');
            else if (type === 'warning') display.classList.add('text-yellow-500');
            else display.classList.add('text-indigo-600');
            
            // Clear message after 3 seconds
            setTimeout(() => {
                if (display.textContent === text) {
                    display.textContent = '';
                }
            }, 3000);
        }

        // Event Listeners
        document.getElementById('wordInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') submitWord();
        });

        // Handle page unload - cleanup connections
        window.addEventListener('beforeunload', () => {
            if (multiplayerState.peer) {
                multiplayerState.connections.forEach(conn => conn.close());
                multiplayerState.peer.destroy();
            }
        });

        // Initialize
        updatePlayersDisplay();
    </script>
</body>
</html>
